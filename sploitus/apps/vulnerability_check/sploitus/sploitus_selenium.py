import time
import sys
import os
from selenium.webdriver.support import expected_conditions as EC

sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))

from selenium import webdriver
from selenium.webdriver.chrome.service import Service
from selenium.webdriver.common.by import By
from selenium import webdriver
from webdriver_manager.chrome import ChromeDriverManager
from selenium.webdriver.support.ui import WebDriverWait

# Импортируйте модели Django
from ..models import VulnData, VulnTool  # Замените 'yourapp' на имя вашего приложения

class ParserSploitus():
    def __init__(self):
        self.service = Service(ChromeDriverManager().install())
        self.options = webdriver.ChromeOptions()
        # self.options.add_argument('--headless') 
        self.options.add_argument("--window-size=1920,1080")  # Установите высокое разрешение
        self.options.add_argument("--disable-gpu")  # Отключить GPU
        self.options.add_argument("--no-sandbox")  # Для стабильности в Linux
        self.options.add_argument("--disable-dev-shm-usage")  # Устранение ограничений на использование памяти
        self.options.add_argument("--disable-extensions")  # Отключение лишних расширений
        self.options.add_argument("--disable-blink-features=AutomationControlled")

        self.driver = webdriver.Chrome(service=self.service, options=self.options)

        self.wait = WebDriverWait(self.driver, 60)

    def check_vuln_tools(self, tool_name: str) -> int:
        try:
            vuln_tool, created = VulnTool.objects.get_or_create(name=tool_name)
            return vuln_tool.id
        except Exception as e:
            print(f"Error checking vuln tools: {e}")
            return None
        
    def ten_new_vuln(request_name: str):
        query = (
            VulnData.objects
            .filter(request=request_name)
            .order_by('-vuln_date', '-vulnerability_indicator')
        )

        return query[:10]

    def save_vuln_data_to_db(self, request, vuln_title, vuln_date, description, vuln_sample, sploitus_id, vulnerability_indicator, vuln_tools_id):
        try:
            # Проверка на существование записи
            if not VulnData.objects.filter(
                request=request,
                vuln_title=vuln_title,
                vuln_date=vuln_date,
                description=description,
                vuln_sample=vuln_sample,
                sploitus_id=sploitus_id,
                vulnerability_indicator=vulnerability_indicator,
                vuln_tool_id=vuln_tools_id
            ).exists():
                vuln_data = VulnData(
                    request=request,
                    vuln_title=vuln_title,
                    vuln_date=vuln_date,
                    description=description,
                    vuln_sample=vuln_sample,
                    sploitus_id=sploitus_id,
                    vulnerability_indicator=vulnerability_indicator,
                    vuln_tool_id=vuln_tools_id
                )
                vuln_data.save()
                print("\t\t\t\t\t\t\t\tSAVE")
        except Exception as e:
            print(f"Error saving vuln data: {e}")

    def ten_new_vuln(self, request_name: str):
        try:
            # Возвращает последние 10 записей для данного запроса
            return VulnData.objects.filter(request=request_name).order_by('-vuln_date', '-vulnerability_indicator')[:10]
        except Exception as e:
            print(f"Error fetching ten new vuln data: {e}")
            return []

    def check_limit(self, limit):
        try:
            count = VulnData.objects.count()
            print(count, limit)

            if limit <= count:
                return False
            return True
        except Exception as e:
            print(f"Error checking limit: {e}")
            return False

    def main(self, request: str):
        try:
            self.driver.get("https://sploitus.com/")
            print("START")
            last_height = self.driver.execute_script("return document.body.scrollHeight")

            # search_box  = self.driver.find_element(By.XPATH, '//*[@id="search-box"]/div/div/form/fieldset/div/input')
            search_box = self.wait.until(
                EC.visibility_of_element_located((By.XPATH, '//*[@id="search-box"]/div/div/form/fieldset/div/input'))
            )
            search_box.send_keys(request)

            # search_button = self.driver.find_element(By.XPATH, '//*[@id="search-box"]/div/div/form/fieldset/div/button')
            search_button = self.wait.until(
                EC.element_to_be_clickable((By.XPATH, '//*[@id="search-box"]/div/div/form/fieldset/div/button'))
            )
            search_button.click()

            while True:
                try:
                    limit_element = WebDriverWait(self.driver, 100).until(EC.visibility_of_element_located((By.XPATH, '//div[@id="tabs"]/ul/li[1]/a')))
                    limit = int(limit_element.get_attribute('data-badge'))

                    self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
                    print("LIMIT", self.check_limit(limit))

                    if self.check_limit(limit): 
                        new_height = self.driver.execute_script("return document.body.scrollHeight")

                        if new_height == last_height:
                            break
                        
                        last_height = new_height

                        wait = WebDriverWait(self.driver, 60)
                        wait.until(EC.presence_of_element_located((By.XPATH, '//*[@class="panel"]')))

                        all_data = self.driver.find_elements(By.XPATH, '//*[@class="panel"]')

                        for data in all_data:
                            sploitus_id = data.find_element(By.XPATH, './/div[@class="accordion-body"]/div/div/button[3]').get_attribute("data-id")
                            vuln_title = data.find_element(By.XPATH, ".//div[@class='tile-content']/div[1]").text
                            vuln_date = data.find_element(By.XPATH, ".//div[@class='tile-content']/div[2]").text
                            accordion_button = data.find_element(By.XPATH, './/div[@class="accordion"]')
                            accordion_button.click()

                            WebDriverWait(data, 10).until(
                                EC.visibility_of_element_located((By.XPATH, './/div[@class="accordion-body"]/div/pre/code'))
                            )

                            description_element = data.find_element(By.XPATH, './/div[@class="accordion-body"]/div/pre/code')
                            description = description_element.text

                            if len(description) > 400:
                                description = description[:400]

                            if ("PoC" in description or "Proof of Concept" in description) and not ("Exploit" in description or "exploit" in description):
                                vuln_sample = "Proof of Concept"
                            else:
                                vuln_sample = "Exploit"

                            vulnerability_indicator = float(data.find_element(By.XPATH, './/div/label/div[1]').get_attribute("data-badge"))
                            vuln_tools = data.find_element(By.XPATH, './/div/label/div[1]/div').get_attribute("class")
                            vuln_tools = vuln_tools[17:] 

                            vuln_tools_id = self.check_vuln_tools(vuln_tools)

                            self.save_vuln_data_to_db(
                                request,
                                vuln_title,
                                vuln_date,
                                description,
                                vuln_sample,
                                sploitus_id,
                                float(vulnerability_indicator),
                                vuln_tools_id
                            )

                            time.sleep(1)
                    else:
                        self.driver.quit()
                        return self.ten_new_vuln(request)
                except Exception as e:
                    print(f"ERROR: {e}")
                    break

        finally:
            self.driver.quit()
