# from . import models
# from playwright.async_api import async_playwright
# from django.db.models import Count
# from asgiref.sync import sync_to_async
# from asgiref.sync import async_to_sync


# def check_vuln_tools(name: str) -> int:
#     vuln_tool, created = models.VulnTool.objects.get_or_create(name=name)

#     return vuln_tool.pk

# def save_vuln_data_to_db(request, vuln_title, vuln_date, description, vuln_sample, sploitus_id, vulnerability_indicator, vuln_tool_id):
#     # Получаем объект VulnTool по ID, чтобы передать его в VulnData
#     vuln_tool = models.VulnTool.objects.get(pk=vuln_tool_id)

#     # Проверяем, существует ли уже такая запись
#     if models.VulnData.objects.filter(
#         request=request,
#         vuln_title=vuln_title,
#         vuln_date=vuln_date,
#         vuln_sample=vuln_sample,
#         sploitus_id=sploitus_id,
#         vulnerability_indicator=vulnerability_indicator,
#         description=description,
#         vuln_tool=vuln_tool  # Передаем экземпляр VulnTool
#     ).exists():
#         return  # Если запись существует, выходим

#     # Создаем новую запись
#     vuln = models.VulnData(
#         request=request,
#         vuln_title=vuln_title,
#         vuln_date=vuln_date,
#         vuln_sample=vuln_sample,
#         sploitus_id=sploitus_id,
#         vulnerability_indicator=vulnerability_indicator,
#         description=description,
#         vuln_tool=vuln_tool  # Передаем экземпляр VulnTool
#     )
#     vuln.save()  # Сохраняем запись в базу
#     print("\t\t\t\t\t\t\t\tSAVE")



# def ten_new_vuln(request_name: str):
#     query = (
#         models.VulnData.objects
#         .filter(request=request_name)  # Фильтрация по названию request
#         .order_by('-vuln_date', '-vulnerability_indicator')  # Сортировка по vuln_date и vulnerability_indicator
#     )
    
#     # Возвращаем до 10 строк, либо все, если записей меньше 10
#     return query[:10] 
        

# def check_limit(limit):
#     count = models.VulnData.objects.count()
#     if limit <= count:
#         return False
#     return True


# check_vuln_tools_async = sync_to_async(check_vuln_tools)
# save_vuln_data_to_db_async = sync_to_async(save_vuln_data_to_db)
# check_limit_async = sync_to_async(check_limit)
# ten_new_vuln_async = sync_to_async(ten_new_vuln)

# from playwright.sync_api import sync_playwright

# async def parse(request: str):
#     print("TASK INSIDE!!!")
#     async with async_playwright() as p:
#         print("TASK INSIDE!!! 2")
#         browser = await p.chromium.launch(headless=False)
#         context = await browser.new_context()
#         page = await context.new_page()

#         await page.goto("https://sploitus.com/", wait_until="load", timeout=60000)

#         while True:
#             # try:
#                 await page.locator('//*[@id="query"]').fill(request)
#                 await page.locator('//*[@id="formfield"]/div/button').click()

#                 await page.evaluate(
#                     """async () => {
#                         let totalHeight = 0;
#                         let distance = 100; 
#                         let lastHeight = 0;
#                         while (totalHeight < document.body.scrollHeight) {
#                             window.scrollBy(0, distance);
#                             await new Promise(resolve => setTimeout(resolve, 200)); 
                            
#                             totalHeight = document.body.scrollHeight;

#                             if (lastHeight === totalHeight) {
#                                 break;
#                             }
                            
#                             lastHeight = totalHeight;
#                         }
#                     }"""
#                 )

#                 await page.wait_for_selector('//div[@id="tabs"]/ul/li[1]/a')

#                 limit = await page.locator('//div[@id="tabs"]/ul/li[1]/a').get_attribute('data-badge')

#                 if await check_limit_async(int(limit)):
#                     all_data = await page.locator('//*[@class="panel"]').all()

#                     for data in all_data:
#                         sploitus_id = await data.locator('//div[@class="accordion-body"]/div/div/button[3]').get_attribute("data-id")

#                         vuln_title = await data.locator("//div[@class='tile-content']/div[1]").text_content()
#                         vuln_date = await data.locator("//div[@class='tile-content']/div[2]").text_content()
                        

#                         description = await data.locator('//div[@class="accordion-body"]/div/pre/code').text_content()

#                         if (("PoC" or "Proof of Concept") in description) and not (("Exploit" or "exploit") in description):
#                             vuln_sample = "Proof of Concept"
#                         else:
#                             vuln_sample = "Exploit"

#                         vulnerability_indicator = await data.locator('//div/label/div[1]').get_attribute("data-badge")

#                         vuln_tool = await data.locator('//div/label/div[1]/div').get_attribute("class")
#                         vuln_tool = vuln_tool[17:]

#                         vuln_tool_id = await check_vuln_tools_async(vuln_tool)

#                         await save_vuln_data_to_db_async(
#                             request,
#                             vuln_title,
#                             vuln_date,
#                             description,
#                             vuln_sample,
#                             sploitus_id,
#                             float(vulnerability_indicator),
#                             vuln_tool_id,
#                         )

#                 else:
#                     await browser.close()
#                     # print(ten_new_vuln(request))
#                     results = await ten_new_vuln_async(request)  # Убедитесь, что результаты возвращаются
#                     return results

#             # except Exception as e:
#             #     print(f"ERROR: {e}")
#             #     break

# @async_to_sync
# async def main(request):
#     await parse(request)

from . import models
from playwright.sync_api import sync_playwright
from django.db.models import Count


def check_vuln_tools(name: str) -> int:
    vuln_tool, created = models.VulnTool.objects.get_or_create(name=name)
    return vuln_tool.pk


def save_vuln_data_to_db(request, vuln_title, vuln_date, description, vuln_sample, sploitus_id, vulnerability_indicator, vuln_tool_id):
    # Получаем объект VulnTool по ID, чтобы передать его в VulnData
    vuln_tool = models.VulnTool.objects.get(pk=vuln_tool_id)

    # Проверяем, существует ли уже такая запись
    if models.VulnData.objects.filter(
        request=request,
        vuln_title=vuln_title,
        vuln_date=vuln_date,
        vuln_sample=vuln_sample,
        sploitus_id=sploitus_id,
        vulnerability_indicator=vulnerability_indicator,
        description=description,
        vuln_tool=vuln_tool
    ).exists():
        return  # Если запись существует, выходим

    # Создаем новую запись
    vuln = models.VulnData(
        request=request,
        vuln_title=vuln_title,
        vuln_date=vuln_date,
        vuln_sample=vuln_sample,
        sploitus_id=sploitus_id,
        vulnerability_indicator=vulnerability_indicator,
        description=description,
        vuln_tool=vuln_tool
    )
    vuln.save()  # Сохраняем запись в базу
    print("\t\t\t\t\t\t\t\tSAVE")


def ten_new_vuln(request_name: str):
    query = (
        models.VulnData.objects
        .filter(request=request_name)
        .order_by('-vuln_date', '-vulnerability_indicator')
    )
    return query[:10]


def check_limit(limit):
    count = models.VulnData.objects.count()
    return limit > count


def parse(request: str):
    print("TASK INSIDE!!!")
    with sync_playwright() as p:
        print("TASK INSIDE!!! 2")
        browser = p.chromium.launch(headless=False)
        context = browser.new_context()
        page = context.new_page()

        page.goto("https://sploitus.com/", wait_until="load", timeout=60000)

        while True:
            try:
                page.locator('//*[@id="query"]').fill(request)
                page.locator('//*[@id="formfield"]/div/button').click()

                page.evaluate(
                    """() => {
                        let totalHeight = 0;
                        let distance = 100; 
                        let lastHeight = 0;
                        return new Promise(resolve => {
                            const interval = setInterval(() => {
                                window.scrollBy(0, distance);
                                totalHeight = document.body.scrollHeight;

                                if (lastHeight === totalHeight) {
                                    clearInterval(interval);
                                    resolve();
                                }

                                lastHeight = totalHeight;
                            }, 200);
                        });
                    }"""
                )

                page.wait_for_selector('//div[@id="tabs"]/ul/li[1]/a')

                limit = int(page.locator('//div[@id="tabs"]/ul/li[1]/a').get_attribute('data-badge'))

                if check_limit(limit):
                    all_data = page.locator('//*[@class="panel"]').all()

                    for data in all_data:
                        sploitus_id = data.locator('//div[@class="accordion-body"]/div/div/button[3]').get_attribute("data-id")

                        vuln_title = data.locator("//div[@class='tile-content']/div[1]").text_content()
                        vuln_date = data.locator("//div[@class='tile-content']/div[2]").text_content()
                        
                        description = data.locator('//div[@class="accordion-body"]/div/pre/code').text_content()

                        if (("PoC" in description or "Proof of Concept" in description) and 
                            not ("Exploit" in description or "exploit" in description)):
                            vuln_sample = "Proof of Concept"
                        else:
                            vuln_sample = "Exploit"

                        vulnerability_indicator = float(data.locator('//div/label/div[1]').get_attribute("data-badge"))

                        vuln_tool = data.locator('//div/label/div[1]/div').get_attribute("class")[17:]
                        vuln_tool_id = check_vuln_tools(vuln_tool)

                        save_vuln_data_to_db(
                            request,
                            vuln_title,
                            vuln_date,
                            description,
                            vuln_sample,
                            sploitus_id,
                            vulnerability_indicator,
                            vuln_tool_id,
                        )
                else:
                    browser.close()
                    return ten_new_vuln(request)

            except Exception as e:
                print(f"ERROR: {e}")
                break


def main(request):
    parse(request)