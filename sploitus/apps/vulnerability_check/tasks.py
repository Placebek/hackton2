# import json
# from celery import shared_task
# from .models import UserVuln, VulnData, VulnTool
# from . import sploitus_parser


# @shared_task
# def parse_query_task(user_vuln_id):
#     try:
#         # Получаем запись UserVuln
#         user_vuln = UserVuln.objects.get(id=user_vuln_id)

#         # Инициализируем парсер и выполняем парсинг
#         parser = sploitus_parser()
#         results = parser.main(user_vuln.request)  # Возвращает список объектов

#         # Сохраняем результаты в VulnData
#         for result in results:
#             VulnData.objects.create(
#                 request=user_vuln.request,
#                 vuln_title=result.get("vuln_title"),
#                 vuln_date=result.get("vuln_date", datetime.now().strftime("%Y-%m-%d")),
#                 vuln_sample=result.get("vuln_sample"),
#                 sploitus_id=result.get("sploitus_id"),
#                 vulnerability_indicator=result.get("vulnerability_indicator"),
#                 description=result.get("description"),
#                 task_interval=user_vuln.task_interval,
#                 user=user_vuln.user,
#                 vuln_tool=None,  # Свяжите с инструментом, если применимо
#             )
#         print(f"Парсинг завершен для запроса: {user_vuln.request}")
#     except Exception as e:
#         print(f"Ошибка при парсинге: {e}")


from celery import shared_task
from .models import VulnData
#from .parser import .....
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
import json
from channels.layers import get_channel_layer
from asgiref.sync import async_to_sync

# @shared_task
# def parse_resource_task(vuln_data_id):
#     try:
#         vuln_data = VulnData.objects.get(id=vuln_data_id)
#         task_interval = vuln_data.task_interval
#         results = parse_resource(vuln_data.request)

#         vuln_data.request = results.get('request', vuln_data.request)
#         vuln_data.vuln_title = results.get('vuln_title', 'Unknown')
#         vuln_data.vuln_date = results.get('vuln_date', '')
#         vuln_data.vuln_sample =  results.get('vuln_sample', '')
#         vuln_data.sploitus_id = results.get('sploitus_id', '')
#         vuln_data.vulnerability_indicator = results.get('vulnerability_indicator', 0.0) 
#         vuln_data.description = results.get('description', '')

#         vuln_data.save()

#         channel_layer = get_channel_layer()
#         async_to_sync(channel_layer.group_send)(
#             "notifications",
#             {
#                 "type": "task_update",
#                 "message": f"Parsing completed for {vuln_data.request}",
#             }
#         )
#         parse_resource_task.apply_async((vuln_data_id,), countdown=task_interval * 60)

#     except VulnData.DoesNotExist:
#         print(f"VulnData with id {vuln_data_id} does not exist.")

from . import serializers
from .sploitus.sploitus_selenium import ParserSploitus

@shared_task
def parse_query_task(query):
    # try:
        print("TASK STARTED!!!")
        # Выполняем парсинг
        # result = sploitus_parser.main(query)
        parser_sploitus = ParserSploitus()
        result = parser_sploitus.main(query)

        vuln_data_serializer = serializers.VulnDataResultSerializer(result, many=True)

        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            "check_notifications",  # Название группы WebSocket, связанное с задачей
            {
                "type": "parsing_result_message",  # Пользовательский тип сообщения
                "message": json.dumps({
                    "status": "completed",
                    "query": query,
                    "result": vuln_data_serializer.data
                })
            }
        )
    # except Exception as e:
    #     print("EXCEPTION OCCURRED", e)
    #     channel_layer = get_channel_layer()
    #     async_to_sync(channel_layer.group_send)(
    #         "check_notifications",  # Название группы WebSocket, связанное с задачей
    #         {
    #             "type": "parsing_result_message",  # Пользовательский тип сообщения
    #             "message": json.dumps({
    #                 "status": "failed",
    #                 "query": query,
    #                 "error": str(e),
    #             })
    #         }
    #     )
