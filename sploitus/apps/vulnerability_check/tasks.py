from celery import shared_task
from asgiref.sync import async_to_sync
from channels.layers import get_channel_layer
import json
from .sploitus.sploitus_selenium import ParserSploitus
from .sploitus.sploitus_selenium_bot import ParserSploitusBot
from . import serializers


@shared_task
def parse_query_task(query, task_interval, interval_category):
    try:
        # Преобразование интервала в секунды в зависимости от категории
        if interval_category == 'секунда' or interval_category == 'секунды':
            countdown = task_interval
        elif interval_category == 'минута' or interval_category == 'минуты':
            countdown = task_interval * 60  # Переводим минуты в секунды
        elif interval_category == 'час' or interval_category == 'часы':
            countdown = task_interval * 3600  # Переводим часы в секунды
        elif interval_category == 'день' or interval_category == 'дни':
            countdown = task_interval * 86400  # Переводим дни в секунды
        else:
            raise ValueError("Unsupported interval category")

        # Выполняем парсинг
        parser_sploitus = ParserSploitus()
        result = parser_sploitus.main(query)

        # Сериализация результата
        vuln_data_serializer = serializers.VulnDataResultSerializer(result, many=True)

        # Отправка данных через WebSocket
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            "check_notifications",  # Название группы WebSocket
            {
                "type": "parsing_result_message",  # Тип сообщения для обработки на клиенте
                "message": json.dumps({
                    "status": "completed",
                    "query": query,
                    "result": vuln_data_serializer.data
                })
            }
        )

        # Повторное выполнение задачи через указанный интервал
        parse_query_task.apply_async((query, task_interval, interval_category), countdown=countdown)
    except Exception as e:
        print("EXCEPTION OCCURRED", e)
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            "check_notifications",  # Название группы WebSocket, связанное с задачей
            {
                "type": "parsing_result_message",  # Пользовательский тип сообщения
                "message": json.dumps({
                    "status": "failed",
                    "query": query,
                    "error": str(e),
                })
            }
        )

@shared_task
def query_task(query):
    try:
        # Выполняем парсинг
        # result = sploitus_parser.main(query)
        parser_sploitus = ParserSploitus()
        result = parser_sploitus.main(query)

        vuln_data_serializer = serializers.VulnDataResultSerializer(result, many=True)

        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            "check_notifications",  # Название группы WebSocket, связанное с задачей
            {
                "type": "parsing_result_message",  # Пользовательский тип сообщения
                "message": json.dumps({
                    "status": "completed",
                    "query": query,
                    "result": vuln_data_serializer.data
                })
            }
        )
    except Exception as e:
        print("EXCEPTION OCCURRED", e)
        channel_layer = get_channel_layer()
        async_to_sync(channel_layer.group_send)(
            "check_notifications",  # Название группы WebSocket, связанное с задачей
            {
                "type": "parsing_result_message",  # Пользовательский тип сообщения
                "message": json.dumps({
                    "status": "failed",
                    "query": query,
                    "error": str(e),
                })
            }
        )

@shared_task
def pars_query_task_bot(query):
    try:
        # Выполнение парсинга
        parser_sploitus = ParserSploitusBot()
        result = parser_sploitus.main(query)

        # Сериализация результата
        vuln_data_serializer = serializers.VulnDataResultSerializer(result, many=True)

        # Возвращаем результат
        return {
            "status": "completed",
            "query": query,
            "result": vuln_data_serializer.data
        }
    except Exception as e:
        print(f"Error: {e}")
        # В случае ошибки возвращаем информацию об ошибке
        return {
            "status": "error",
            "message": f"An error occurred: {str(e)}"
        }
