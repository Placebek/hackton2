from django.shortcuts import render
from rest_framework import generics
from .models import *
from .serializers import *
from rest_framework.response import Response
from rest_framework import status
from .serializers import VulnDataSerializer
from rest_framework.views import APIView
from datetime import datetime
#from .tasks import parse_resource_task
from rest_framework.decorators import api_view
from . import tasks
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from rest_framework.permissions import IsAuthenticated


class CheckCreateApiView(generics.CreateAPIView):
    serializer_class = VulnDataSerializer

    @swagger_auto_schema(
    operation_description="Отправка домена или IP-адреса",
    responses={200: VulnDataSerializer(many=True)},
    manual_parameters=[
        openapi.Parameter(
            'resource',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL, в теле запроса, и т.д.)
            description="Домен или IP-адрес для проверки",  # Описание параметра
            type=openapi.TYPE_STRING,  # Тип параметра
            required=True,  # Является ли обязательным
        ),
        openapi.Parameter(
            'task_interval',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL)
            description="Интервал задачи в минутах",  # Описание параметра
            type=openapi.TYPE_INTEGER,  # Тип параметра
            required=False,  # Не обязательный
        ),
    ]
    )

    def create_check(self, request):
        serializer = self.serializer_class(data=request.data)

        if serializer.is_valid:
            serializer.save()

            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    

# class RecourceCheckView(APIView):
#     def post(self, request, *args, **kwargs):
#         data = request.data
#         domain_or_ip = data.get('resource')
#         task_interval = data.get('task_interval', 5)

#         if not domain_or_ip:
#             return Response({'error': 'Resource is required'}, status=status.HTTP_400_BAD_REQUEST)
        
#         vuln_data = VulnData.objects.create(
#             request = domain_or_ip,
#             vuln_title = "Ожидайте...",
#             vuln_data = datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#             description = None,
#             sploitus_id = None,
#             vulnerability_indicator=None,
#             user=request.user,
#             vuln_tool=None,
#             task_interval=task_interval
#         )

#         parse_resource_task.apply_async((vuln_data.id,), countdown=task_interval * 10)

#         return Response({'message': "Ресурс сохранен и начат синтаксический анализ"}, status=status.HTTP_201_CREATED)
    

class FrequencyParserApiView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        print("DDDDD: ", self.request.user)

        return Response({
            "asd": True
        })
    
    def post(self, request):
        serializer = VulnDataRequestSerializer(data=request.data)
        
        if serializer.is_valid():
            # Добавляем user из токена и другие данные
            vuln_data = UserVuln.objects.create(
                request=serializer.validated_data['request'],
                user=self.request.user,  # Из JWT
                task_interval=serializer.validated_data['task_interval'],
                interval_category=serializer.validated_data['interval_category'],
            )

            return Response({
                "message": "Запись успешно создана",
                "id": vuln_data.id,
                "request": vuln_data.request
            }, status=status.HTTP_201_CREATED)
        else:
            return Response({
                "errors": serializer.errors
            }, status=status.HTTP_400_BAD_REQUEST)



@api_view(['POST'])
def index(request):
    query = request.data.get("query")
    try:
        tasks.parse_query_task.delay(query)

        # results = sploitus_parser.parse(query)
        # print("RRRRRRESS: ", results)

        return Response({
            "status": 'in progress',
        })
    except Exception as e:
        return Response({
            "status": 'error',
        }, status=500)
