from django.shortcuts import render
from rest_framework import generics
from .models import *
from .serializers import *
from rest_framework.response import Response
from rest_framework import status
from .serializers import VulnDataSerializer, BotRequestSerializer
from rest_framework.views import APIView
from rest_framework.decorators import api_view
from . import tasks
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from rest_framework.permissions import IsAuthenticated
from bot_decorator import bot_authenticated


# --- Create Check API View ---
class CheckCreateApiView(generics.CreateAPIView):
    serializer_class = VulnDataSerializer

    @swagger_auto_schema(
        operation_description="Создает проверку на основе домена или IP-адреса.",
        request_body=VulnDataSerializer,
        responses={
            201: openapi.Response("Запрос успешно выполнен", VulnDataSerializer),
            400: "Ошибка валидации данных"
        },
        manual_parameters=[
            openapi.Parameter(
                'resource',
                openapi.IN_QUERY,
                description="Домен или IP-адрес для проверки",
                type=openapi.TYPE_STRING,
                required=True,
            ),
            openapi.Parameter(
                'task_interval',
                openapi.IN_QUERY,
                description="Интервал задачи в минутах",
                type=openapi.TYPE_INTEGER,
                required=False,
            ),
        ]
    )
    def create_check(self, request):
        serializer = self.serializer_class(data=request.data)

        if serializer.is_valid():
            serializer.save()
            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)


# --- Frequency Parser API View ---
class FrequencyParserApiView(APIView):
    permission_classes = [IsAuthenticated]

    @swagger_auto_schema(
        operation_description="Получение информации о текущем пользователе.",
        responses={
            200: "Успешный ответ",
            401: "Неавторизованный запрос"
        }
    )
    def get(self, request):
        return Response({"asd": True})

    @swagger_auto_schema(
        operation_description="Создает запись с указанными данными.",
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                "request": openapi.Schema(type=openapi.TYPE_STRING, description="Запрос для анализа"),
                "task_interval": openapi.Schema(type=openapi.TYPE_INTEGER, description="Интервал задачи"),
                "interval_category": openapi.Schema(type=openapi.TYPE_STRING, description="Категория интервала"),
            },
            required=["request", "task_interval", "interval_category"]
        ),
        responses={
            201: "Запись успешно создана",
            400: "Ошибка валидации данных"
        }
    )
    def post(self, request):
        serializer = VulnDataRequestSerializer(data=request.data)

        if serializer.is_valid():
            vuln_data = UserVuln.objects.create(
                request=serializer.validated_data['request'],
                user=self.request.user,
                task_interval=serializer.validated_data['task_interval'],
                interval_category=serializer.validated_data['interval_category'],
            )
            return Response({
                "message": "Запись успешно создана",
                "id": vuln_data.id,
                "request": vuln_data.request
            }, status=status.HTTP_201_CREATED)
        return Response({"errors": serializer.errors}, status=status.HTTP_400_BAD_REQUEST)


# --- Query Task API View ---
class QueryTaskView(APIView):
    permission_classes = [IsAuthenticated]

    @swagger_auto_schema(
        operation_description="Создает задачу для анализа по указанному запросу.",
        request_body=openapi.Schema(
            type=openapi.TYPE_OBJECT,
            properties={
                "query": openapi.Schema(type=openapi.TYPE_STRING, description="Запрос для анализа"),
                "task_interval": openapi.Schema(type=openapi.TYPE_INTEGER, description="Интервал задачи"),
                "interval_category": openapi.Schema(type=openapi.TYPE_STRING, description="Категория интервала"),
            },
            required=["query", "task_interval", "interval_category"]
        ),
        responses={
            202: "Задача успешно запущена",
            400: "Отсутствуют обязательные параметры",
            500: "Ошибка сервера"
        }
    )
    def post(self, request, *args, **kwargs):
        query = request.data.get("query")
        task_interval = request.data.get("task_interval")
        interval_category = request.data.get("interval_category")

        if not query:
            return Response({"status": "error", "message": "query is required"}, status=status.HTTP_400_BAD_REQUEST)

        if not task_interval or not interval_category:
            return Response({"status": "error", "message": "task_interval and interval_category are required"},
                            status=status.HTTP_400_BAD_REQUEST)

        try:
            user_vuln = UserVuln.objects.create(
                request=query,
                task_interval=task_interval,
                interval_category=interval_category,
                user=request.user
            )

            tasks.parse_query_task.delay(query, task_interval, interval_category)

            return Response({
                "status": 'in progress',
                "message": f"Task for query '{query}' started with interval {task_interval} {interval_category}",
            }, status=status.HTTP_202_ACCEPTED)
        except Exception as e:
            return Response({"status": 'error', "message": str(e)}, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


# --- Index Task ---
@swagger_auto_schema(
    method='post',
    operation_description="Запускает задачу для указанного запроса.",
    request_body=openapi.Schema(
        type=openapi.TYPE_OBJECT,
        properties={
            "query": openapi.Schema(type=openapi.TYPE_STRING, description="Запрос для анализа"),
        },
        required=["query"]
    ),
    responses={
        202: "Задача успешно запущена",
        500: "Ошибка выполнения"
    }
)
@api_view(['POST'])
def index(request):
    query = request.data.get("query")
    try:
        tasks.query_task.delay(query)
        return Response({"status": 'in progress'})
    except Exception as e:
        return Response({"status": 'error'}, status=500)


# --- Bot Task ---
@swagger_auto_schema(
    method='post',
    operation_description="Запускает задачу от имени бота. Требует заголовок формата Authorization: APIKEY <API-ключ вашего бота, выданный нашим сервисом>",
    request_body=openapi.Schema(
        type=openapi.TYPE_OBJECT,
        properties={
            "query": openapi.Schema(type=openapi.TYPE_STRING, description="Запрос для анализа"),
        },
        required=["query"]
    ),
    responses={
        202: "Задача успешно запущена",
        400: "Ошибка: query обязателен"
    }
)
@api_view(['POST'])
@bot_authenticated
def bot_task(request, *args, **kwargs):
    query = request.data.get("query")

    if not query:
        return Response({"status": "error", "message": "query is required"}, status=status.HTTP_400_BAD_REQUEST)

    bot_request = models.BotRequest.objects.create(bot=request.bot, request=query)

    tasks.pars_query_task_bot.delay(query, bot_request.pk)

    return Response({"status": "in progress"}, status=status.HTTP_202_ACCEPTED)


# --- My Vulnerabilities ---
@swagger_auto_schema(
    method='get',
    operation_description="Получает все запросы, отправленные ботом.",
    responses={
        200: BotRequestSerializer(many=True),
        404: "BotRequest not found"
    }
)
@api_view(['GET'])
@bot_authenticated
def my_vulnerabilities(request):
    try:
        bot_requests = models.BotRequest.objects.filter(bot=request.bot)
        bot_request_serializer = BotRequestSerializer(bot_requests, many=True)
        return Response(bot_request_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)


# --- Get Vulnerability by ID ---
@swagger_auto_schema(
    method='get',
    operation_description="Получает уязвимости по ID запроса.",
    responses={
        200: VulnDataBotSerializer(many=True),
        404: "BotRequest not found"
    }
)
@api_view(['GET'])
@bot_authenticated
def get_vulnerability_by_id(request, query_id):
    try:
        bot_request = models.BotRequest.objects.filter(pk=query_id, bot=request.bot).last()
        vuln_data_bots = models.VulnDataBot.objects.filter(bot_request=bot_request)
        vuln_data_bot_serializer = VulnDataBotSerializer(vuln_data_bots, many=True)
        return Response(vuln_data_bot_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)


# --- Get All Vulnerabilities ---
@swagger_auto_schema(
    method='get',
    operation_description="Получает все уязвимости, связанные с ботом.",
    responses={
        200: VulnDataBotSerializer(many=True),
        404: "BotRequest not found"
    }
)
@api_view(['GET'])
@bot_authenticated
def get_all_vulnerabilities(request):
    try:
        bot_request = models.BotRequest.objects.filter(bot=request.bot).last()
        vuln_data_bots = models.VulnDataBot.objects.filter(bot_request=bot_request)
        vuln_data_bot_serializer = VulnDataBotSerializer(vuln_data_bots, many=True)
        return Response(vuln_data_bot_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)
