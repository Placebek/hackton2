from django.shortcuts import render
from rest_framework import generics
from .models import *
from .serializers import *
from rest_framework.response import Response
from rest_framework import status
from .serializers import VulnDataSerializer, BotRequestSerializer
from rest_framework.views import APIView
from datetime import datetime
#from .tasks import parse_resource_task
from rest_framework.decorators import api_view
from . import tasks
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from rest_framework.permissions import IsAuthenticated
from bot_decorator import bot_authenticated
from rest_framework import status


class CheckCreateApiView(generics.CreateAPIView):
    serializer_class = VulnDataSerializer

    @swagger_auto_schema(
    operation_description="Отправка домена или IP-адреса",
    responses={200: VulnDataSerializer(many=True)},
    manual_parameters=[
        openapi.Parameter(
            'resource',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL, в теле запроса, и т.д.)
            description="Домен или IP-адрес для проверки",  # Описание параметра
            type=openapi.TYPE_STRING,  # Тип параметра
            required=True,  # Является ли обязательным
        ),
        openapi.Parameter(
            'task_interval',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL)
            description="Интервал задачи в минутах",  # Описание параметра
            type=openapi.TYPE_INTEGER,  # Тип параметра
            required=False,  # Не обязательный
        ),
    ]
    )

    def create_check(self, request):
        serializer = self.serializer_class(data=request.data)

        if serializer.is_valid:
            serializer.save()

            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    

class FrequencyParserApiView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        print("DDDDD: ", self.request.user)

        return Response({
            "asd": True
        })
    
    def post(self, request):
        serializer = VulnDataRequestSerializer(data=request.data)
        
        if serializer.is_valid():
            # Добавляем user из токена и другие данные
            vuln_data = UserVuln.objects.create(
                request=serializer.validated_data['request'],
                user=self.request.user,  # Из JWT
                task_interval=serializer.validated_data['task_interval'],
                interval_category=serializer.validated_data['interval_category'],
            )

            return Response({
                "message": "Запись успешно создана",
                "id": vuln_data.id,
                "request": vuln_data.request
            }, status=status.HTTP_201_CREATED)
        else:
            return Response({
                "errors": serializer.errors
            }, status=status.HTTP_400_BAD_REQUEST)


class QueryTaskView(APIView):
    permission_classes = [IsAuthenticated]
    def post(self, request, *args, **kwargs):
        query = request.data.get("query")
        task_interval = request.data.get("task_interval")
        interval_category = request.data.get("interval_category")

        if not query:
            return Response({
                "status": "error",
                "message": "query is required"
            }, status=status.HTTP_400_BAD_REQUEST)

        if not task_interval or not interval_category:
            return Response({
                "status": "error",
                "message": "task_interval and interval_category are required"
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Создание записи для пользователя
            user_vuln = UserVuln.objects.create(
                request=query,
                task_interval=task_interval,
                interval_category=interval_category,
                user=request.user  # предполагается, что вы получаете пользователя через request.user
            )

            # Отправляем задачу в Celery с дополнительными параметрами
            tasks.parse_query_task.delay(query, task_interval, interval_category)

            return Response({
                "status": 'in progress',
                "message": f"Task for query '{query}' started with interval {task_interval} {interval_category}",
            }, status=status.HTTP_202_ACCEPTED)
        except Exception as e:
            return Response({
                "status": 'error',
                "message": str(e),
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)
        
    
@api_view(['POST'])
def index(request):
    query = request.data.get("query")
    try:
        tasks.query_task.delay(query)

        # results = sploitus_parser.parse(query)
        # print("RRRRRRESS: ", results)

        return Response({
            "status": 'in progress',
        })
    except Exception as e:
        return Response({
            "status": 'error',
        }, status=500)
    

@api_view(['POST'])
@bot_authenticated
def bot_task(request, *args, **kwargs):
        query = request.data.get("query")
        
        if not query:
            return Response({
                "status": "error",
                "message": "query is required"
            }, status=status.HTTP_400_BAD_REQUEST)

        try:
            # Отправляем задачу в Celery с запросом
            tasks.pars_query_task_bot.delay(query)

            return Response({
                "status": "in progress",
            }, status=status.HTTP_202_ACCEPTED)

        except Exception as e:
            return Response({
                "status": "error",
                "message": str(e)
            }, status=status.HTTP_500_INTERNAL_SERVER_ERROR)


@api_view(['GET'])
@bot_authenticated
def my_vulnerabilities(request):
    try:
        bot_requests = models.BotRequest.objects.filter(bot = request.bot)
        bot_request_serializer = BotRequestSerializer(bot_requests, many=True)

        return Response(bot_request_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
@bot_authenticated
def get_vulnerability_by_id(request, query_id):
    try:
        # Получаем BotRequest по переданному id
        bot_request = models.BotRequest.objects.get(pk=query_id)

        # Получаем все VulnDataBot связанные с этим BotRequest
        vuln_data_bots = models.VulnDataBot.objects.filter(bot_request=bot_request)

        # Сериализуем данные
        vuln_data_bot_serializer = VulnDataBotSerializer(vuln_data_bots, many=True)

        return Response(vuln_data_bot_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)


@api_view(['GET'])
@bot_authenticated
def get_all_vulnerabilities(request):
    try:
        # Получаем BotRequest по переданному id
        bot_request = models.BotRequest.objects.get(bot=request.bot)

        # Получаем все VulnDataBot связанные с этим BotRequest
        vuln_data_bots = models.VulnDataBot.objects.filter(bot_request=bot_request)

        # Сериализуем данные
        vuln_data_bot_serializer = VulnDataBotSerializer(vuln_data_bots, many=True)

        return Response(vuln_data_bot_serializer.data, status=status.HTTP_200_OK)
    except models.BotRequest.DoesNotExist:
        return Response({"detail": "BotRequest not found."}, status=status.HTTP_404_NOT_FOUND)
