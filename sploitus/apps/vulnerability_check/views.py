from django.shortcuts import render
from rest_framework import generics
from .models import *
from .serializers import *
from rest_framework.response import Response
from rest_framework import status
from .serializers import VulnDataSerializer
from rest_framework.views import APIView
from datetime import datetime
#from .tasks import parse_resource_task
from rest_framework.decorators import api_view
from . import tasks
from drf_yasg.utils import swagger_auto_schema
from drf_yasg import openapi
from rest_framework.permissions import IsAuthenticated
from .tasks import parse_query_task


class CheckCreateApiView(generics.CreateAPIView):
    serializer_class = VulnDataSerializer

    @swagger_auto_schema(
    operation_description="Отправка домена или IP-адреса",
    responses={200: VulnDataSerializer(many=True)},
    manual_parameters=[
        openapi.Parameter(
            'resource',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL, в теле запроса, и т.д.)
            description="Домен или IP-адрес для проверки",  # Описание параметра
            type=openapi.TYPE_STRING,  # Тип параметра
            required=True,  # Является ли обязательным
        ),
        openapi.Parameter(
            'task_interval',  # Имя параметра
            openapi.IN_QUERY,  # Тип (в URL)
            description="Интервал задачи в минутах",  # Описание параметра
            type=openapi.TYPE_INTEGER,  # Тип параметра
            required=False,  # Не обязательный
        ),
    ]
    )

    def create_check(self, request):
        serializer = self.serializer_class(data=request.data)

        if serializer.is_valid:
            serializer.save()

            return Response(serializer.data, status=status.HTTP_201_CREATED)
        return Response(serializer.errors, status=status.HTTP_400_BAD_REQUEST)
    

# class RecourceCheckView(APIView):
#     def post(self, request, *args, **kwargs):
#         data = request.data
#         domain_or_ip = data.get('resource')
#         task_interval = data.get('task_interval', 5)

#         if not domain_or_ip:
#             return Response({'error': 'Resource is required'}, status=status.HTTP_400_BAD_REQUEST)
        
#         vuln_data = VulnData.objects.create(
#             request = domain_or_ip,
#             vuln_title = "Ожидайте...",
#             vuln_data = datetime.now().strftime("%Y-%m-%d %H:%M:%S"),
#             description = None,
#             sploitus_id = None,
#             vulnerability_indicator=None,
#             user=request.user,
#             vuln_tool=None,
#             task_interval=task_interval
#         )

#         parse_resource_task.apply_async((vuln_data.id,), countdown=task_interval * 10)

#         return Response({'message': "Ресурс сохранен и начат синтаксический анализ"}, status=status.HTTP_201_CREATED)
    

class FrequencyParserApiView(APIView):
    permission_classes = [IsAuthenticated]

    def get(self, request):
        print("DDDDD: ", self.request.user)

        return Response({
            "asd": True
        })
    
    def post(self, request):
        serializer = VulnDataRequestSerializer(data=request.data)
        
        if serializer.is_valid():
            # Добавляем user из токена и другие данные
            vuln_data = UserVuln.objects.create(
                request=serializer.validated_data['request'],
                user=self.request.user,  # Из JWT
                task_interval=serializer.validated_data['task_interval'],
                interval_category=serializer.validated_data['interval_category'],
            )

            return Response({
                "message": "Запись успешно создана",
                "id": vuln_data.id,
                "request": vuln_data.request
            }, status=status.HTTP_201_CREATED)
        else:
            return Response({
                "errors": serializer.errors
            }, status=status.HTTP_400_BAD_REQUEST)


class ParseQueryApiView(APIView):
    #permission_classes = [IsAuthenticated]

    def post(self, request, *args, **kwargs):
        query = request.data.get("query")
        if not query:
            return Response(
                {"error": "Поле 'query' обязательно."},
                status=status.HTTP_400_BAD_REQUEST
            )
        try:
            # Запуск асинхронной задачи Celery
            tasks.parse_query_task.delay(query)

            return Response(
                {"status": "in progress"},
                status=status.HTTP_200_OK
            )
        except Exception as e:
            return Response(
                {"status": "error", "detail": str(e)},
                status=status.HTTP_500_INTERNAL_SERVER_ERROR
            )
        

class UserVulnApiView(APIView):
    permission_classes = [IsAuthenticated]  # Только для аутентифицированных пользователей

    def post(self, request, *args, **kwargs):
        # Получаем данные из тела запроса
        user_request = request.data.get("request")
        task_interval = request.data.get("task_interval", 5)  # По умолчанию 5 минут

        if not user_request:
            return Response(
                {"error": "Поле 'request' обязательно."},
                status=status.HTTP_400_BAD_REQUEST,
            )

        # Создаем или обновляем запись UserVuln
        user_vuln, created = UserVuln.objects.update_or_create(
            request=user_request,
            user=request.user,
            defaults={"task_interval": task_interval, "interval_category": "custom"},
        )

        # Асинхронный вызов задачи парсинга через Celery
        parse_query_task.delay(user_vuln.id)

        return Response(
            {
                "message": "Запрос принят. Парсинг начат.",
                "user_vuln": {
                    "id": user_vuln.id,
                    "request": user_vuln.request,
                    "task_interval": user_vuln.task_interval,
                },
            },
            status=status.HTTP_200_OK,
        )